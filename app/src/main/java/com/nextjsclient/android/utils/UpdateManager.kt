package com.nextjsclient.android.utils

import android.app.DownloadManager
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.net.Uri
import android.os.Environment
import android.util.Log
import androidx.core.content.FileProvider
import java.io.File
import kotlinx.coroutines.*
import org.json.JSONObject
import org.json.JSONArray
import java.net.HttpURLConnection
import java.net.URL

data class Release(
    val tagName: String,
    val name: String,
    val body: String,
    val downloadUrl: String,
    val publishedAt: String
)

class UpdateManager(private val context: Context) {
    
    companion object {
        private const val TAG = "UpdateManager"
        private const val GITHUB_API_URL = "https://api.github.com/repos/foXaCe/NextJSClientAndroid/releases"
        // Test: interface de mise √† jour am√©lior√©e avec progression
    }
    
    interface UpdateListener {
        fun onUpdateChecking()
        fun onUpdateAvailable(release: Release)
        fun onUpToDate()
        fun onDownloadStarted()
        fun onDownloadProgress(progress: Int)
        fun onDownloadCompleted(file: File)
        fun onInstallationStarted()
        fun onError(message: String)
    }
    
    private var listener: UpdateListener? = null
    private var downloadId: Long = -1
    
    fun setUpdateListener(listener: UpdateListener) {
        this.listener = listener
    }
    
    /**
     * Nettoie les anciennes APK du dossier Downloads
     * Supprime tous les fichiers NextJSClient*.apk
     */
    fun cleanOldApks() {
        try {
            val downloadsDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
            if (downloadsDir.exists() && downloadsDir.isDirectory) {
                val apkFiles = downloadsDir.listFiles { file ->
                    file.name.startsWith("NextJSClient") && file.name.endsWith(".apk")
                }
                
                apkFiles?.forEach { file ->
                    try {
                        if (file.delete()) {
                            Log.d(TAG, "Deleted old APK: ${file.name}")
                        } else {
                            Log.w(TAG, "Failed to delete: ${file.name}")
                        }
                    } catch (e: Exception) {
                        Log.e(TAG, "Error deleting ${file.name}: ${e.message}")
                    }
                }
                
                val deletedCount = apkFiles?.size ?: 0
                if (deletedCount > 0) {
                    Log.i(TAG, "Cleaned $deletedCount old APK file(s) from Downloads")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error cleaning old APKs: ${e.message}")
        }
    }
    
    suspend fun checkForUpdates() {
        withContext(Dispatchers.IO) {
            try {
                Log.d(TAG, "üîç Starting update check...")
                Log.d(TAG, "üèõÔ∏è Repository: foXaCe/NextJSClientAndroid")
                withContext(Dispatchers.Main) {
                    listener?.onUpdateChecking()
                }
                
                Log.d(TAG, "Requesting: $GITHUB_API_URL")
                val url = URL(GITHUB_API_URL)
                val connection = url.openConnection() as HttpURLConnection
                connection.requestMethod = "GET"
                connection.setRequestProperty("Accept", "application/vnd.github.v3+json")
                // Ajouter token GitHub pour repository priv√© si n√©cessaire
                // connection.setRequestProperty("Authorization", "token YOUR_GITHUB_TOKEN")
                connection.connectTimeout = 10000
                connection.readTimeout = 10000
                
                Log.d(TAG, "Response code: ${connection.responseCode}")
                
                if (connection.responseCode == HttpURLConnection.HTTP_OK) {
                    val response = connection.inputStream.bufferedReader().use { it.readText() }
                    Log.d(TAG, "Response received: ${response.take(200)}...")
                    val releasesArray = JSONArray(response)
                    
                    if (releasesArray.length() == 0) {
                        withContext(Dispatchers.Main) {
                            listener?.onUpToDate()
                        }
                        return@withContext
                    }
                    
                    // Prendre la premi√®re release (la plus r√©cente)
                    val latestRelease = releasesArray.getJSONObject(0)
                    
                    val tagName = latestRelease.getString("tag_name")
                    val name = if (latestRelease.has("name") && !latestRelease.isNull("name")) {
                        val releaseName = latestRelease.getString("name").trim()
                        // Si le nom est vide ou contient juste des espaces, utiliser tagName
                        if (releaseName.isNotEmpty()) releaseName else tagName
                    } else {
                        tagName // Utiliser tagName si name n'existe pas
                    }
                    val body = latestRelease.getString("body")
                    val publishedAt = latestRelease.getString("published_at")
                    
                    Log.d(TAG, "Raw release name from GitHub: '${if (latestRelease.has("name")) latestRelease.getString("name") else "null"}'")
                    Log.d(TAG, "Processed release name: '$name'")
                    Log.d(TAG, "Tag name: '$tagName'")
                    Log.d(TAG, "Published: $publishedAt")
                    
                    // Find APK download URL in assets
                    val assets = latestRelease.getJSONArray("assets")
                    Log.d(TAG, "Found ${assets.length()} assets")
                    var downloadUrl = ""
                    
                    for (i in 0 until assets.length()) {
                        val asset = assets.getJSONObject(i)
                        val assetName = asset.getString("name")
                        Log.d(TAG, "Asset $i: $assetName")
                        // Prioriser app-debug.apk pour les tests
                        if (assetName == "app-debug.apk" || assetName.endsWith(".apk")) {
                            downloadUrl = asset.getString("browser_download_url")
                            Log.d(TAG, "Found APK: $downloadUrl")
                            if (assetName == "app-debug.apk") break // Prioriser app-debug.apk
                        }
                    }
                    
                    if (downloadUrl.isEmpty()) {
                        Log.w(TAG, "No APK found in assets")
                        withContext(Dispatchers.Main) {
                            listener?.onError("Aucun APK trouv√© dans la release")
                        }
                        return@withContext
                    }
                    
                    val currentVersion = getCurrentVersion()
                    val latestVersion = tagName.removePrefix("v")
                    
                    Log.d(TAG, "Current version: $currentVersion")
                    Log.d(TAG, "Latest version: $latestVersion")
                    
                    // R√©cup√©rer tous les noms d'assets
                    val assetNames = mutableListOf<String>()
                    for (i in 0 until assets.length()) {
                        val asset = assets.getJSONObject(i)
                        assetNames.add(asset.getString("name"))
                    }
                    
                    val release = Release(tagName, name, body, downloadUrl, publishedAt)
                    val isNewer = isNewerVersion(currentVersion, latestVersion, release, assetNames)
                    Log.d(TAG, "Is newer version available: $isNewer")
                    
                    withContext(Dispatchers.Main) {
                        if (isNewer) {
                            Log.d(TAG, "‚úÖ GitHub release available: ${release.tagName}")
                            Log.d(TAG, "üì¶ Download URL: ${release.downloadUrl}")
                            listener?.onUpdateAvailable(release)
                        } else {
                            Log.d(TAG, "‚ùå No GitHub release available")
                            listener?.onUpToDate()
                        }
                    }
                } else if (connection.responseCode == HttpURLConnection.HTTP_NOT_FOUND) {
                    Log.w(TAG, "Repository or releases not found (404)")
                    withContext(Dispatchers.Main) {
                        listener?.onError("Repository non trouv√© (404)")
                    }
                } else {
                    Log.e(TAG, "HTTP Error: ${connection.responseCode} - ${connection.responseMessage}")
                    withContext(Dispatchers.Main) {
                        listener?.onError("Erreur de connexion: ${connection.responseCode}")
                    }
                }
                
                connection.disconnect()
                
            } catch (e: Exception) {
                Log.e(TAG, "Error checking for updates: ${e.message}", e)
                Log.e(TAG, "Exception type: ${e.javaClass.simpleName}")
                withContext(Dispatchers.Main) {
                    listener?.onUpToDate() // Fallback silencieux en cas d'erreur
                }
            }
        }
    }
    
    private fun cleanOldUpdates(keepFileName: String? = null) {
        try {
            // Utiliser le dossier cache externe de l'app (pas de permissions requises)
            val appUpdateDir = File(context.externalCacheDir, "updates")
            if (appUpdateDir.exists() && appUpdateDir.isDirectory) {
                // Supprimer les anciens APK NextJSClient et les fichiers temporaires d'installation
                val oldFiles = appUpdateDir.listFiles { file ->
                    (file.name.startsWith("NextJSClient-") || file.name.startsWith("install_")) && 
                    file.name.endsWith(".apk") &&
                    file.name != keepFileName
                }
                
                oldFiles?.forEach { file ->
                    Log.d(TAG, "üóëÔ∏è Deleting old NextJSClient APK: ${file.name}")
                    val deleted = file.delete()
                    if (deleted) {
                        Log.d(TAG, "   ‚úÖ Successfully deleted: ${file.name}")
                    } else {
                        Log.w(TAG, "   ‚ö†Ô∏è Failed to delete: ${file.name}")
                    }
                }
                
                if (oldFiles?.isNotEmpty() == true) {
                    Log.d(TAG, "‚úÖ Cleaned ${oldFiles.size} old NextJSClient APK file(s)")
                } else {
                    Log.d(TAG, "üìã No old NextJSClient APK files to clean")
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error cleaning old updates", e)
        }
    }
    
    fun downloadUpdate(release: Release) {
        try {
            Log.d(TAG, "üöÄ === D√âBUT T√âL√âCHARGEMENT ===")
            Log.d(TAG, "üìã Release info:")
            Log.d(TAG, "   ‚Ä¢ Tag: ${release.tagName}")
            Log.d(TAG, "   ‚Ä¢ Name: ${release.name}")
            Log.d(TAG, "   ‚Ä¢ URL: ${release.downloadUrl}")
            
            val fileName = "NextJSClient-${release.tagName}.apk"
            Log.d(TAG, "üìÅ Target filename: $fileName")
            
            // Nettoyer les anciennes mises √† jour avant de t√©l√©charger (garde le nouveau nom)
            cleanOldUpdates(keepFileName = fileName)
            
            // Utiliser le dossier cache externe de l'app (pas de permissions requises)
            val appUpdateDir = File(context.externalCacheDir, "updates")
            Log.d(TAG, "üìÇ Updates directory: ${appUpdateDir.absolutePath}")
            Log.d(TAG, "üìä Directory exists before: ${appUpdateDir.exists()}")
            Log.d(TAG, "üìä Directory writable: ${appUpdateDir.canWrite()}")
            
            if (!appUpdateDir.exists()) {
                val created = appUpdateDir.mkdirs()
                Log.d(TAG, "üìÅ Directory creation result: $created")
                Log.d(TAG, "üìÅ Created updates directory: ${appUpdateDir.absolutePath}")
            }
            
            // V√©rifier si le fichier existe d√©j√† et le supprimer
            val existingFile = File(appUpdateDir, fileName)
            if (existingFile.exists()) {
                Log.d(TAG, "‚ö†Ô∏è File already exists: ${existingFile.name}")
                val deleted = existingFile.delete()
                if (deleted) {
                    Log.d(TAG, "‚úÖ Deleted existing file: ${existingFile.name}")
                } else {
                    Log.w(TAG, "‚ùå Failed to delete existing file: ${existingFile.name}")
                }
            }
            
            Log.d(TAG, "üìä Directory exists after: ${appUpdateDir.exists()}")
            Log.d(TAG, "üìä Directory permissions: ${appUpdateDir.canRead()}/${appUpdateDir.canWrite()}")
            
            // Lister le contenu du r√©pertoire avant t√©l√©chargement
            Log.d(TAG, "üìã Directory contents BEFORE download:")
            val nextjsFiles = appUpdateDir.listFiles { file ->
                file.name.startsWith("NextJSClient-") && file.name.endsWith(".apk")
            }
            nextjsFiles?.forEach { file ->
                Log.d(TAG, "   ‚Ä¢ ${file.name} (${file.length()} bytes)")
            } ?: Log.d(TAG, "   ‚Ä¢ No NextJSClient APK files found")
            
            Log.d(TAG, "üó∫ Storage info: App external cache directory (no permissions required)")
            
            val destinationFile = File(appUpdateDir, fileName)
            Log.d(TAG, "üìÇ Expected destination file: ${destinationFile.absolutePath}")
            
            // Utiliser setDestinationUri pour sp√©cifier le chemin exact dans le cache externe
            val destinationUri = Uri.fromFile(File(appUpdateDir, fileName))
            
            val request = DownloadManager.Request(Uri.parse(release.downloadUrl))
                .setTitle("NextJS Client Update")
                .setDescription("T√©l√©chargement de la mise √† jour ${release.tagName}")
                .setDestinationUri(destinationUri)
                .setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE)
                .setAllowedOverMetered(true)
                .setAllowedOverRoaming(true)
            
            Log.d(TAG, "‚öôÔ∏è DownloadManager request configured")
            Log.d(TAG, "   ‚Ä¢ Title: NextJS Client Update")
            Log.d(TAG, "   ‚Ä¢ Description: T√©l√©chargement de la mise √† jour ${release.tagName}")
            Log.d(TAG, "   ‚Ä¢ Destination: ${destinationUri.path}")
            
            val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
            downloadId = downloadManager.enqueue(request)
            Log.d(TAG, "üì• Download enqueued with ID: $downloadId")
            Log.d(TAG, "üìÇ File will be saved as: $fileName in app directory")
            
            listener?.onDownloadStarted()
            
            // Start monitoring download progress avec le bon chemin
            Log.d(TAG, "üîç Starting download monitoring for path: ${destinationFile.absolutePath}")
            startDownloadMonitoring(destinationFile.absolutePath)
            
            Log.d(TAG, "‚úÖ === FIN CONFIGURATION T√âL√âCHARGEMENT ===")
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error downloading update", e)
            Log.e(TAG, "‚ùå Exception type: ${e.javaClass.simpleName}")
            Log.e(TAG, "‚ùå Exception message: ${e.message}")
            Log.e(TAG, "‚ùå Stack trace: ${e.stackTraceToString()}")
            listener?.onError("Erreur de t√©l√©chargement: ${e.message}")
        }
    }
    
    private fun startDownloadMonitoring(filePath: String) {
        Log.d(TAG, "üîç === D√âBUT MONITORING T√âL√âCHARGEMENT ===")
        Log.d(TAG, "üìÇ Monitoring file path: $filePath")
        Log.d(TAG, "üÜî Download ID: $downloadId")
        
        // Use a coroutine to monitor download progress periodically
        CoroutineScope(Dispatchers.IO).launch {
            val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as DownloadManager
            var iterationCount = 0
            
            while (true) {
                delay(500) // Check every 500ms for better progress tracking
                iterationCount++
                
                Log.d(TAG, "üîÑ Monitoring iteration #$iterationCount")
                
                val query = DownloadManager.Query().setFilterById(downloadId)
                val cursor = downloadManager.query(query)
                
                Log.d(TAG, "üìã Query result: cursor count = ${cursor.count}")
                
                if (cursor.moveToFirst()) {
                    val statusIndex = cursor.getColumnIndex(DownloadManager.COLUMN_STATUS)
                    val status = cursor.getInt(statusIndex)
                    
                    val bytesDownloadedIndex = cursor.getColumnIndex(DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR)
                    val bytesTotalIndex = cursor.getColumnIndex(DownloadManager.COLUMN_TOTAL_SIZE_BYTES)
                    val localUriIndex = cursor.getColumnIndex(DownloadManager.COLUMN_LOCAL_URI)
                    val reasonIndex = cursor.getColumnIndex(DownloadManager.COLUMN_REASON)
                    
                    val bytesDownloaded = cursor.getLong(bytesDownloadedIndex)
                    val bytesTotal = cursor.getLong(bytesTotalIndex)
                    val localUri = cursor.getString(localUriIndex) ?: "null"
                    val reason = cursor.getInt(reasonIndex)
                    
                    Log.d(TAG, "üìä Download status: $status, Progress: $bytesDownloaded/$bytesTotal bytes")
                    Log.d(TAG, "üìç Local URI: $localUri")
                    Log.d(TAG, "üîç Reason code: $reason")
                    
                    when (status) {
                        DownloadManager.STATUS_SUCCESSFUL -> {
                            Log.d(TAG, "‚úÖ === T√âL√âCHARGEMENT TERMIN√â AVEC SUCC√àS ===")
                            Log.d(TAG, "üìç Local URI from DownloadManager: $localUri")
                            Log.d(TAG, "üìä Final download stats: $bytesDownloaded/$bytesTotal bytes")
                            
                            cursor.close()
                            
                            // Analyse d√©taill√©e du fichier via l'URI du DownloadManager
                            if (localUri != "null" && localUri.isNotEmpty()) {
                                Log.d(TAG, "üîç Analysing DownloadManager URI: $localUri")
                                try {
                                    val uri = Uri.parse(localUri)
                                    val fileFromUri = File(uri.path ?: "")
                                    Log.d(TAG, "üìÇ File from URI: ${fileFromUri.absolutePath}")
                                    Log.d(TAG, "üìä File from URI exists: ${fileFromUri.exists()}")
                                    if (fileFromUri.exists()) {
                                        Log.d(TAG, "üìè File from URI size: ${fileFromUri.length()} bytes")
                                    }
                                } catch (e: Exception) {
                                    Log.w(TAG, "‚ö†Ô∏è Could not parse DownloadManager URI: ${e.message}")
                                }
                            }
                            
                            // Chercher le fichier t√©l√©charg√© dans le cache externe de l'app
                            val appUpdateDir = File(context.externalCacheDir, "updates")
                            Log.d(TAG, "üîç === ANALYSE DU R√âPERTOIRE UPDATES ===")
                            Log.d(TAG, "üìÇ Directory path: ${appUpdateDir.absolutePath}")
                            Log.d(TAG, "üìä Directory exists: ${appUpdateDir.exists()}")
                            Log.d(TAG, "üìä Directory readable: ${appUpdateDir.canRead()}")
                            Log.d(TAG, "üìä Directory writable: ${appUpdateDir.canWrite()}")
                            
                            // Lister TOUT le contenu du r√©pertoire
                            Log.d(TAG, "üìã ALL directory contents:")
                            appUpdateDir.listFiles()?.forEach { file ->
                                Log.d(TAG, "   ‚Ä¢ ALL: ${file.name} (${file.length()} bytes, isFile: ${file.isFile}, readable: ${file.canRead()})")
                            } ?: Log.w(TAG, "   ‚Ä¢ Directory listFiles() returned null!")
                            
                            // Chercher sp√©cifiquement les APK
                            val downloadedFiles = appUpdateDir.listFiles { _, name ->
                                name.endsWith(".apk")
                            }
                            
                            Log.d(TAG, "üì¶ APK files search result: ${downloadedFiles?.size ?: 0} files")
                            
                            val downloadFile = when {
                                downloadedFiles?.isNotEmpty() == true -> {
                                    Log.d(TAG, "üì¶ Found ${downloadedFiles.size} APK file(s):")
                                    downloadedFiles.forEachIndexed { index, file ->
                                        Log.d(TAG, "   ‚Ä¢ APK[$index]: ${file.name} (${file.length()} bytes)")
                                        Log.d(TAG, "     Path: ${file.absolutePath}")
                                        Log.d(TAG, "     Exists: ${file.exists()}, Readable: ${file.canRead()}")
                                    }
                                    Log.d(TAG, "üéØ Using first APK file: ${downloadedFiles.first().name}")
                                    downloadedFiles.first() // Prendre le premier fichier APK trouv√©
                                }
                                else -> {
                                    Log.w(TAG, "‚ö†Ô∏è No APK files found in directory, trying original path...")
                                    Log.d(TAG, "üìÇ Fallback to original path: $filePath")
                                    File(filePath)
                                }
                            }
                            
                            Log.d(TAG, "üìÇ === V√âRIFICATION FICHIER FINAL ===")
                            Log.d(TAG, "üìÇ Final file to check: ${downloadFile.absolutePath}")
                            Log.d(TAG, "üìä File exists: ${downloadFile.exists()}")
                            Log.d(TAG, "üìä File readable: ${downloadFile.canRead()}")
                            Log.d(TAG, "üìè File size: ${downloadFile.length()} bytes")
                            Log.d(TAG, "üìÖ File last modified: ${downloadFile.lastModified()}")
                            
                            if (downloadFile.exists() && downloadFile.length() > 0) {
                                Log.d(TAG, "üéâ === FICHIER TROUV√â ET VALIDE ===")
                                Log.d(TAG, "‚úÖ File found! Size: ${downloadFile.length()} bytes")
                                
                                // Copier le fichier vers un emplacement s√ªr avant de nettoyer l'entr√©e DownloadManager
                                val safeFile = File(appUpdateDir, "install_${downloadFile.name}")
                                try {
                                    downloadFile.copyTo(safeFile, overwrite = true)
                                    Log.d(TAG, "üìÅ Fichier copi√© vers: ${safeFile.absolutePath}")
                                    
                                    // Maintenant on peut nettoyer l'entr√©e DownloadManager sans perdre le fichier
                                    try {
                                        downloadManager.remove(downloadId)
                                        Log.d(TAG, "üßπ Entr√©e DownloadManager nettoy√©e")
                                    } catch (e: Exception) {
                                        Log.w(TAG, "Could not clear download entry: ${e.message}")
                                    }
                                    
                                    withContext(Dispatchers.Main) {
                                        Log.d(TAG, "üöÄ Notifying download completion to UI")
                                        listener?.onDownloadCompleted(safeFile)
                                    }
                                } catch (e: Exception) {
                                    Log.e(TAG, "Erreur lors de la copie du fichier: ${e.message}")
                                    // En cas d'erreur, utiliser le fichier original
                                    withContext(Dispatchers.Main) {
                                        listener?.onDownloadCompleted(downloadFile)
                                    }
                                }
                            } else {
                                Log.e(TAG, "‚ùå === FICHIER NON TROUV√â OU INVALIDE ===")
                                Log.e(TAG, "‚ùå Downloaded file not found or empty!")
                                Log.d(TAG, "üóÇÔ∏è Complete directory contents for debugging:")
                                
                                // Analyse compl√®te du r√©pertoire parent aussi
                                val parentDir = context.getExternalFilesDir(null)
                                Log.d(TAG, "üìÅ Parent directory: ${parentDir?.absolutePath}")
                                parentDir?.listFiles()?.forEach { file ->
                                    Log.d(TAG, "   ‚Ä¢ PARENT: ${file.name} (${if (file.isDirectory()) "DIR" else file.length().toString() + " bytes"})")
                                    if (file.isDirectory() && file.name == "updates") {
                                        file.listFiles()?.forEach { subFile ->
                                            Log.d(TAG, "     ‚îî‚îÄ‚îÄ ${subFile.name} (${subFile.length()} bytes)")
                                        }
                                    }
                                }
                                
                                withContext(Dispatchers.Main) {
                                    listener?.onError("Fichier t√©l√©charg√© non trouv√©")
                                }
                            }
                            break
                        }
                        DownloadManager.STATUS_FAILED -> {
                            Log.e(TAG, "‚ùå === T√âL√âCHARGEMENT √âCHOU√â ===")
                            Log.e(TAG, "‚ùå Download failed! Reason: $reason")
                            Log.e(TAG, "üìä Download stats at failure: $bytesDownloaded/$bytesTotal bytes")
                            Log.e(TAG, "üìç Local URI: $localUri")
                            
                            // D√©coder les raisons d'√©chec
                            val reasonText = when (reason) {
                                DownloadManager.ERROR_CANNOT_RESUME -> "Cannot resume download"
                                DownloadManager.ERROR_DEVICE_NOT_FOUND -> "Device not found"
                                DownloadManager.ERROR_FILE_ALREADY_EXISTS -> "File already exists"
                                DownloadManager.ERROR_FILE_ERROR -> "File error"
                                DownloadManager.ERROR_HTTP_DATA_ERROR -> "HTTP data error"
                                DownloadManager.ERROR_INSUFFICIENT_SPACE -> "Insufficient space"
                                DownloadManager.ERROR_TOO_MANY_REDIRECTS -> "Too many redirects"
                                DownloadManager.ERROR_UNHANDLED_HTTP_CODE -> "Unhandled HTTP code"
                                DownloadManager.ERROR_UNKNOWN -> "Unknown error"
                                else -> "Other error ($reason)"
                            }
                            Log.e(TAG, "‚ùå Failure reason: $reasonText")
                            
                            cursor.close()
                            withContext(Dispatchers.Main) {
                                listener?.onError("√âchec du t√©l√©chargement: $reasonText")
                            }
                            break
                        }
                        DownloadManager.STATUS_RUNNING -> {
                            if (bytesTotal > 0 && bytesTotal != -1L) {
                                val progress = ((bytesDownloaded * 100) / bytesTotal).toInt().coerceIn(1, 100) // Au minimum 1% si on t√©l√©charge
                                Log.d(TAG, "üèÉ Download in progress: $progress% ($bytesDownloaded/$bytesTotal bytes)")
                                withContext(Dispatchers.Main) {
                                    listener?.onDownloadProgress(progress)
                                }
                            } else {
                                // Taille inconnue - estimer le progr√®s bas√© sur les bytes t√©l√©charg√©s
                                // Estimation bas√©e sur la taille typique d'APK ~12-13 MB
                                val estimatedTotalSize = 13 * 1024 * 1024 // 13 MB estim√©
                                val estimatedProgress = when {
                                    bytesDownloaded == 0L -> 1 // Au moins 1% si le t√©l√©chargement a commenc√©
                                    bytesDownloaded < 512 * 1024 -> 5  // < 0.5MB -> 5%
                                    bytesDownloaded < 1024 * 1024 -> 8  // < 1MB -> 8%
                                    bytesDownloaded < 2 * 1024 * 1024 -> 15  // < 2MB -> 15%
                                    bytesDownloaded < 4 * 1024 * 1024 -> 30  // < 4MB -> 30%
                                    bytesDownloaded < 6 * 1024 * 1024 -> 45  // < 6MB -> 45%
                                    bytesDownloaded < 8 * 1024 * 1024 -> 60  // < 8MB -> 60%
                                    bytesDownloaded < 10 * 1024 * 1024 -> 75 // < 10MB -> 75%
                                    bytesDownloaded < 12 * 1024 * 1024 -> 85 // < 12MB -> 85%
                                    else -> {
                                        // Pour les derniers MB, calculer pr√©cis√©ment si possible
                                        val calculatedProgress = ((bytesDownloaded * 100) / estimatedTotalSize).toInt()
                                        minOf(95, maxOf(90, calculatedProgress)) // Entre 90-95%
                                    }
                                }.coerceIn(1, 95) // Ne jamais d√©passer 95% sans conna√Ætre la taille totale exacte
                                
                                val sizeMB = String.format("%.1f", bytesDownloaded / 1024.0 / 1024.0)
                                Log.d(TAG, "üèÉ Download running, size unknown: ${sizeMB}MB downloaded (estimated $estimatedProgress%)")
                                withContext(Dispatchers.Main) {
                                    listener?.onDownloadProgress(estimatedProgress)
                                }
                            }
                        }
                        DownloadManager.STATUS_PENDING -> {
                            Log.d(TAG, "‚è≥ Download pending...")
                        }
                        DownloadManager.STATUS_PAUSED -> {
                            Log.w(TAG, "‚è∏Ô∏è Download paused. Reason: $reason")
                        }
                        else -> {
                            Log.w(TAG, "‚ùì Unknown download status: $status")
                        }
                    }
                } else {
                    Log.w(TAG, "‚ö†Ô∏è === T√âL√âCHARGEMENT INTROUVABLE DANS CURSOR ===")
                    Log.w(TAG, "‚ö†Ô∏è Download not found in cursor for ID: $downloadId")
                    Log.w(TAG, "üìä Cursor count: ${cursor.count}")
                    cursor.close()
                    withContext(Dispatchers.Main) {
                        listener?.onError("T√©l√©chargement introuvable")
                    }
                    break
                }
                cursor.close()
            }
            
            Log.d(TAG, "üîö === FIN MONITORING T√âL√âCHARGEMENT ===")
        }
    }
    
    fun installUpdate(file: File) {
        try {
            Log.d(TAG, "üì¶ === D√âBUT INSTALLATION ===")
            Log.d(TAG, "üìÇ File path: ${file.absolutePath}")
            Log.d(TAG, "üìä File exists: ${file.exists()}")
            Log.d(TAG, "üìä File readable: ${file.canRead()}")
            Log.d(TAG, "üìè File size: ${file.length()} bytes")
            
            // V√©rifier que le fichier existe et est valide
            if (!file.exists()) {
                Log.e(TAG, "‚ùå Le fichier APK n'existe pas: ${file.absolutePath}")
                listener?.onError("Fichier APK introuvable")
                return
            }
            
            if (!file.canRead()) {
                Log.e(TAG, "‚ùå Le fichier APK n'est pas lisible: ${file.absolutePath}")
                listener?.onError("Impossible de lire le fichier APK")
                return
            }
            
            if (file.length() == 0L) {
                Log.e(TAG, "‚ùå Le fichier APK est vide: ${file.absolutePath}")
                listener?.onError("Le fichier APK est vide")
                return
            }
            
            Log.d(TAG, "‚úÖ Fichier APK valide, pr√©paration de l'installation...")
            
            val uri = FileProvider.getUriForFile(
                context,
                "${context.packageName}.fileprovider",
                file
            )
            
            Log.d(TAG, "üìç FileProvider URI: $uri")
            
            val intent = Intent(Intent.ACTION_VIEW).apply {
                setDataAndType(uri, "application/vnd.android.package-archive")
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
            }
            
            // Note: Si l'installation √©choue avec une erreur de signature,
            // l'utilisateur devra d√©sinstaller manuellement l'ancienne version
            // car les APK GitHub et locaux ont des signatures diff√©rentes
            Log.i(TAG, "üì¶ Lancement de l'installation...")
            Log.i(TAG, "‚ö†Ô∏è Si l'installation √©choue, d√©sinstallez d'abord l'app actuelle")
            
            // Notifier que l'installation a commenc√©
            listener?.onInstallationStarted()
            
            context.startActivity(intent)
            Log.d(TAG, "‚úÖ === FIN LANCEMENT INSTALLATION ===")
            
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Error installing update", e)
            Log.e(TAG, "‚ùå Exception type: ${e.javaClass.simpleName}")
            Log.e(TAG, "‚ùå Exception message: ${e.message}")
            Log.e(TAG, "‚ùå Stack trace: ${e.stackTraceToString()}")
            listener?.onError("Erreur d'installation: ${e.message}")
        }
    }
    
    private fun getCurrentVersion(): String {
        return try {
            // Utiliser BuildConfig.VERSION_DISPLAY_NAME comme Lawnchair
            val versionDisplayName = com.nextjsclient.android.BuildConfig.VERSION_DISPLAY_NAME
            Log.d(TAG, "Current app version display name: $versionDisplayName")
            versionDisplayName
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to get current version", e)
            "1.Dev.(unknown)"
        }
    }
    
    private fun isNewerVersion(@Suppress("UNUSED_PARAMETER") _current: String, @Suppress("UNUSED_PARAMETER") _latest: String, release: Release, assetNames: List<String>): Boolean {
        return try {
            // Utiliser BUILD_NUMBER qui contient maintenant le nombre de commits
            val currentBuildNumber = com.nextjsclient.android.BuildConfig.BUILD_NUMBER
            
            // Pour les builds locaux de d√©veloppement
            val isDevBuild = com.nextjsclient.android.BuildConfig.VERSION_DISPLAY_NAME.contains("-dev")
            
            // Extraire le num√©ro de build depuis le nom de l'APK dans les assets
            // Formats attendus: NextJSClient-build221-9096b91.apk (nouveau) ou NextJSClient-run187-9096b91.apk (ancien)
            var releaseBuildNumber = -1
            for (assetName in assetNames) {
                if (assetName.endsWith(".apk")) {
                    // Pattern pour le nouveau format avec build number bas√© sur les commits
                    val buildNumberPattern = Regex("NextJSClient-build(\\d+)-[a-f0-9]{7}\\.apk")
                    var match = buildNumberPattern.find(assetName)
                    
                    // Si pas trouv√©, essayer l'ancien format avec run number (pour compatibilit√©)
                    if (match == null) {
                        val runNumberPattern = Regex("NextJSClient-run(\\d+)-[a-f0-9]{7}\\.apk")
                        match = runNumberPattern.find(assetName)
                    }
                    
                    if (match != null) {
                        releaseBuildNumber = match.groupValues[1].toIntOrNull() ?: -1
                        Log.d(TAG, "Extracted release build number from asset name: $releaseBuildNumber from $assetName")
                        break
                    }
                }
            }
            
            // Si on n'a pas trouv√© de num√©ro dans le nom du fichier, essayer depuis le body de la release
            if (releaseBuildNumber == -1) {
                // Essayer d'abord le nouveau format avec Build Number
                var bodyPattern = Regex("üî¢ Build Number:\\s*(\\d+)")
                var bodyMatch = bodyPattern.find(release.body)
                
                // Si pas trouv√©, essayer l'ancien format avec Run Number
                if (bodyMatch == null) {
                    bodyPattern = Regex("üî¢ Run Number:\\s*(\\d+)")
                    bodyMatch = bodyPattern.find(release.body)
                }
                
                if (bodyMatch != null) {
                    releaseBuildNumber = bodyMatch.groupValues[1].toIntOrNull() ?: -1
                    Log.d(TAG, "Extracted release build number from body: $releaseBuildNumber")
                }
            }
            
            // Extraire le commit hash de la release GitHub
            val releaseCommit = try {
                val pattern = Regex("nightly-\\d{8}-([a-f0-9]{7})")
                val match = pattern.find(release.tagName)
                match?.groupValues?.get(1) ?: ""
            } catch (e: Exception) {
                ""
            }
            
            // Obtenir le commit hash actuel
            val currentCommit = com.nextjsclient.android.BuildConfig.COMMIT_HASH
            
            Log.d(TAG, "=== VERSION COMPARISON ===")
            Log.d(TAG, "Current build number: $currentBuildNumber")
            Log.d(TAG, "Release build number: $releaseBuildNumber")
            Log.d(TAG, "Current commit: $currentCommit")
            Log.d(TAG, "Release commit: $releaseCommit") 
            Log.d(TAG, "Is dev build: $isDevBuild")
            
            // Si on a trouv√© un num√©ro de build dans la release
            if (releaseBuildNumber > 0) {
                // Comparer les num√©ros de build
                // La release est plus r√©cente si son num√©ro de build est sup√©rieur
                val isNewer = releaseBuildNumber > currentBuildNumber
                Log.d(TAG, "Build number comparison: $releaseBuildNumber > $currentBuildNumber = $isNewer")
                return isNewer
            } else {
                // Fallback: si on n'a pas de num√©ro de build, comparer les commits
                Log.d(TAG, "No build number found in release, falling back to commit comparison")
                
                // Si c'est une build de dev et qu'on a le m√™me commit, on est √† jour
                if (isDevBuild && currentCommit == releaseCommit) {
                    Log.d(TAG, "Same commit, no update needed")
                    return false
                }
                
                // Sinon, proposer la mise √† jour seulement si c'est une build dev
                // et que le commit est diff√©rent
                return isDevBuild && releaseCommit.isNotEmpty() && currentCommit != releaseCommit
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error in version check", e)
            false
        }
    }
    
}